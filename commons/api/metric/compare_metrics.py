# AUTOGENERATED! DO NOT EDIT! File to edit: ../../../shardul/api_notebooks/metrics.ipynb.

# %% auto 0
__all__ = ['normalize', 'match_hist', 'normalize_map', 'SIM', 'CC', 'NSS', 'AUC_Judd', 'wasserstein_distance',
           'calculate_metrics']

# %% ../../../shardul/api_notebooks/metrics.ipynb 2
import numpy as np
from numpy import random
from skimage import img_as_float
from skimage import exposure
from cv2 import EMD
from PIL import Image
from skimage.transform import resize
from commons.api.metric.ior import insalient_outsalient_ratio_v2

def normalize(x, method='standard', axis=None):
    '''Normalizes the input with specified method.

    Parameters
    ----------
    x : array-like
    method : string, optional
        Valid values for method are:
        - 'standard': mean=0, std=1
        - 'range': min=0, max=1
        - 'sum': sum=1
    axis : int, optional
        Axis perpendicular to which array is sliced and normalized.
        If None, array is flattened and normalized.

    Returns
    -------
    res : numpy.ndarray
        Normalized array.
    '''
    # TODO: Prevent divided by zero if the map is flat
    x = np.array(x, copy=False)
    if axis is not None:
        y = np.rollaxis(x, axis).reshape([x.shape[axis], -1])
        shape = np.ones(len(x.shape))
        shape[axis] = x.shape[axis]
        if method == 'standard':
            res = (x - np.mean(y, axis=1).reshape(shape)) / np.std(y, axis=1).reshape(shape)
        elif method == 'range':
            res = (x - np.min(y, axis=1).reshape(shape)) / (np.max(y, axis=1) - np.min(y, axis=1)).reshape(shape)
        elif method == 'sum':
            res = x / np.float_(np.sum(y, axis=1).reshape(shape))
        else:
            raise ValueError('method not in {"standard", "range", "sum"}')
    else:
        if method == 'standard':
            res = (x - np.mean(x)) / np.std(x)
        elif method == 'range':
            res = (x - np.min(x)) / (np.max(x) - np.min(x))
        elif method == 'sum':
            res = x / float(np.sum(x))
        else:
            raise ValueError('method not in {"standard", "range", "sum"}')
    return res


def match_hist(image, cdf, bin_centers, nbins=256):
    '''Modify pixels of input image so that its histogram matches target image histogram, specified by:
    cdf, bin_centers = cumulative_distribution(target_image)

    Parameters
    ----------
    image : array
        Image to be transformed.
    cdf : 1D array
        Values of cumulative distribution function of the target histogram.
    bin_centers ; 1D array
        Centers of bins of the target histogram.
    nbins : int, optional
        Number of bins for image histogram.

    Returns
    -------
    out : float array
        Image array after histogram matching.

    References
    ----------
    [1] Matlab implementation histoMatch(MTX, N, X) by Simoncelli, 7/96.
    '''
    image = img_as_float(image)
    old_cdf, old_bin = exposure.cumulative_distribution(image, nbins) # Unlike [1], we didn't add small positive number to the histogram
    new_bin = np.interp(old_cdf, cdf, bin_centers)
    out = np.interp(image.ravel(), old_bin, new_bin)
    return out.reshape(image.shape)

def normalize_map(map):
    min_value = np.min(map)
    max_value = np.max(map)
    normalized_map = (map - min_value) / (max_value - min_value)
    return normalized_map


def SIM(saliency_map1, saliency_map2):
    ''' 
    saliency maps when viewed as distributions, histogram intersection
    (SIM=1 means the distributions are identical).
    '''
    map1 = np.array(saliency_map1, copy=False)
    map2 = np.array(saliency_map2, copy=False)
    if map1.shape != map2.shape:
        map1 = resize(map1, map2.shape, order=3, mode='symmetric') # bi-cubic/nearest is what Matlab imresize() does by default
    # Normalize the two maps to have values between [0,1] and sum up to 1
    map1 = normalize(map1, method='range')
    map2 = normalize(map2, method='range')
    map1 = normalize(map1, method='sum')
    map2 = normalize(map2, method='sum')
    # Compute histogram intersection
    intersection = np.minimum(map1, map2)
    return np.sum(intersection)

def CC(saliency_map1, saliency_map2):
    '''
    Pearson's correlation coefficient between two different saliency maps
    (CC=-1 inverse linear co-relation for CC=0 for uncorrelated maps, CC=1 for perfect linear correlation).
    '''
    map1 = np.array(saliency_map1, copy=False)
    map2 = np.array(saliency_map2, copy=False)
    if map1.shape != map2.shape:
        map1 = resize(map1, map2.shape, order=3, mode='symmetric') # bi-cubic/nearest is what Matlab imresize() does by default
    # Normalize the two maps to have zero mean and unit std
    map1 = normalize(map1, method='standard')
    map2 = normalize(map2, method='standard')
    # Compute correlation coefficient
    return np.corrcoef(map1.ravel(), map2.ravel())[0,1]

def NSS(saliency_map, fixation_map):
    '''
    Normalized scanpath saliency of a saliency map, defined as the mean value of normalized (i.e., standardized) saliency map at fixation locations.
    You can think of it as a z-score. (Larger value implies better performance.)

    Parameters
    ----------
    saliency_map : real-valued matrix
        If the two maps are different in shape, saliency_map will be resized to match fixation_map..
    fixation_map : binary matrix
        Human fixation map (1 for fixated location, 0 for elsewhere).
    Returns
    -------
    NSS : float, positive
    '''
    s_map = np.array(saliency_map, copy=False)
    f_map = np.array(fixation_map, copy=False) > 0.5
    if s_map.shape != f_map.shape:
        s_map = resize(s_map, f_map.shape)
    # Normalize saliency map to have zero mean and unit std
    s_map = normalize(s_map, method='standard')
    # Mean saliency value at fixation locations
    return np.mean(s_map[f_map])


def AUC_Judd(saliency_map, fixation_map, jitter=True):
    '''
    AUC stands for Area Under ROC Curve.
    
    True positive (tp) rate correspond to the ratio of saliency map values above threshold
    at fixation locations to the total number of fixation locations.
    
    False positive (fp) rate correspond to the ratio of saliency map values above threshold
    at all other locations to the total number of possible other locations (non-fixated image pixels).

    AUC=0.5 is chance level.
    '''
    
    saliency_map = np.array(saliency_map, copy=False)
    fixation_map = np.array(fixation_map, copy=False) > 0.5
    # If there are no fixation to predict, return NaN
    if not np.any(fixation_map):
        print('no fixation to predict')
        return np.nan
    # Make the saliency_map the size of the fixation_map
    if saliency_map.shape != fixation_map.shape:
        saliency_map = resize(saliency_map, fixation_map.shape, order=3, mode='symmetric')
    # Jitter the saliency map slightly to disrupt ties of the same saliency value
    if jitter:
        saliency_map += np.random.rand(*saliency_map.shape) * 1e-7
    # Normalize saliency map to have values between [0,1]
    saliency_map = normalize(saliency_map, method='range')

    S = saliency_map.ravel()
    F = fixation_map.ravel()
    S_fix = S[F] # Saliency map values at fixation locations
    n_fix = len(S_fix)
    n_pixels = len(S)
    # Calculate AUC
    thresholds = sorted(S_fix, reverse=True)
    tp = np.zeros(len(thresholds)+2)
    fp = np.zeros(len(thresholds)+2)
    tp[0] = 0; tp[-1] = 1
    fp[0] = 0; fp[-1] = 1
    for k, thresh in enumerate(thresholds):
        above_th = np.sum(S >= thresh) # Total number of saliency map values above threshold
        tp[k+1] = (k + 1) / float(n_fix) # Ratio saliency map values at fixation locations above threshold
        fp[k+1] = (above_th - k - 1) / float(n_pixels - n_fix) # Ratio other saliency map values above threshold
    return np.trapz(tp, fp) # y, x

def wasserstein_distance(cam, perturbed_cam):
    """
    Calculate the Earth Mover's Distance (EMD) between two saliency maps.

    Args:
        cam (numpy.ndarray): Reference saliency map.
        perturbed_cam (numpy.ndarray): Comparison saliency map.

    Returns:
        float: The Earth Mover's Distance (EMD) between the two saliency maps.

    Note:
    - The Earth Mover's Distance is a measure of the dissimilarity between two probability distributions.
    - A small constant is added to the saliency maps to avoid division by zero.
    - If the shapes of the two maps are different, the `perturbed_cam` is resized to match the shape of `cam`.
    - The EMD is computed after normalizing the maps to have values between [0, 1].

    References:
    - The Earth Mover's Distance (EMD) is used as a metric for comparing saliency maps.
    """
    # Add a small constant to avoid division by zero
    if cam.shape != perturbed_cam.shape:
        perturbed_cam = resize(perturbed_cam, cam.shape, order=3, mode='symmetric')

    cam += 1e-6
    perturbed_cam += 1e-6

    cam_max = cam.max()
    perturbed_max = perturbed_cam.max()

    # Normalize cam and perturbed_cam to have values between [0, 1]
    cam_normalized = cam / cam_max
    perturbed_normalized = perturbed_cam / perturbed_max

    emd = EMD(cam_normalized, perturbed_normalized, 1)
    return emd[0]

    
def calculate_metrics(cam, perturbed_cam, mask=None):
    """
    Calculate various saliency metrics, including SIM, CC, NSS, AUC_JUDD, EMD, and IOR (if a mask is provided).

    Args:
        cam (numpy.ndarray): Reference saliency map.
        perturbed_cam (numpy.ndarray): Comparison saliency map.
        mask (numpy.ndarray, optional): Mask generated from YOLO.

    Returns:
        tuple of float values: Metrics values of SIM, CC, NSS, AUC_JUDD, and EMD.
        If a mask is provided, the tuple also includes IOR (Insalient-Outsalient Ratio).
    
    Note:
    - The function calculates various metrics to assess the similarity and quality of saliency maps.
    - If a mask is provided, the IOR (Insalient-Outsalient Ratio) is also calculated.

    References:
    - References to the specific metrics used in this function.
    """
    sim = SIM(cam, perturbed_cam)
    cc = CC(cam, perturbed_cam)
    nss = NSS(cam, perturbed_cam)
    auc_judd = AUC_Judd(cam, perturbed_cam)
    emd = wasserstein_distance(cam, perturbed_cam)
    if mask is not None:
        cam = np.array(Image.fromarray(cam).resize(mask.shape))
        perturbed_cam = np.array(Image.fromarray(perturbed_cam).resize(mask.shape))
    return sim, cc, nss, auc_judd, emd, (insalient_outsalient_ratio_v2(cam, perturbed_cam, mask) if mask is not None else None)
    
